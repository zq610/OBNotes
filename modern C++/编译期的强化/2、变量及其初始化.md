# 变量及其初始化

## 1、if/switch变量声明强化

支持在if和switch语句中声明一个临时变量（像for语句一样）

```cpp
//支持在if/switch语句中初始化变量，用;隔开判断条件
if(int i=0;i!=1)
{
    
}
```



```cpp
//c++17之前
//itr为全局变量，if和switch语句重复使用需要重复定义
const std::vector<int>::iterator itr = std::find(vec.begin(),vec.end(),2);
if(itr!=vec.end())
{
    *itr = 3;
}
const std::vector<int>::iterator itr1 = std::find(vec.begin(),vec.end(),2);
if(itr1!=vec.end())
{
    *itr1 = 4;
}
//C++17之后
//在if/switch语句中直接定义临时变量
if(const std::vector<int>iterator itr = std::find(vec.begin(),vec.end(),3);
   ;iter!=vec.end())
{
    *itr = 4 ; 
}
```

## 2、初始化列表

### 传统初始化方法

#### 1、{}初始化

- 数组
  
  int arry[3] = {1,2,3}

- 没有构造、析构和虚函数的类和结构体
  
  Student s{"xiaowang",12};

#### 2、类对象初始化

- 拷贝构造函数
  
  Student S = Student("xiaowang",12);

- 类似与强制转换
  
  Student S("xiaowang",12); 

### 初始化列表（C++11）

1、用在具有构造函数等的类对象构造上

```cpp
class MagicFoo
{
 public:
     int Num;
     string Name；
     //初始化列表构造函数
     MagicFoo(string a,int b)
    {
       Name = a;
       Num = b;
    }
};

//有构造函数等的类也支持{}列表初始化啦
MagicFoo magic = {“王“, 12};
```

2、作为普通函数的形参

```cpp
void Foo(std::initializer_list<int> list);
Foo({1,2,3,4});
```

### 统一的初始化任意对象方法（C++11）

`Foo foo{”xiaowang“，12};`

## 3、结构化绑定

#### tuple元组实现多返回值

```cpp
#include<tuple>
//利用tuple元组绑定,但不便于从元组中取出元素
std::tuple<int,double,string> Func()
{
    return std::make_tuple(1,2.3,"name");
}
//tuple取元素
std::tuple<int,double,string> tuple1 = Func();
get<0>(tuple1); 


```

#### 结构化绑定

```cpp
auto [x,y,z] = f();
x=1;
y=2.3;
z = "name";
```








