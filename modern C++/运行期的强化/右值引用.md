# 右值引用

C++11引入，和lambda表达式齐名的特性

解决了大量的额外复制开销，也让实现function容器成了可能。

## 1、各种值

> - 左值：表达式之后依旧存在的长久对象；
> 
> - 右值：表达式结束就不再存在的临时对象
>   
>   - 纯右值：纯粹的字面量 1，true，1+2，...（”12345“字符串字面量不是纯右值，因为其类型为const char数组，是一个左值）
>     
>     ```cpp
>     const char * p = "12345";//true,隐式转换为const char*
>     const char*&& pr = "12345";//隐式转换的结果一定是右值，所以可以右值引用
>     const char* & ptr = "12345";//false,不存在左值，不能被引用
>     ```
>   
>   - 将亡值：即将被销毁，但能够移动的值
>     
>     常常为函数的返回值（右值），可以识别，移动，但又快被销毁
>     
>     ```cpp
>     int Func(){int temp = 2;return temp;}
>     
>     int a = Func();
>     //传统C++：会将整个temp拷贝一份，再销毁temp，造成额外开销
>     //c++11:自动将左值temp隐式右值转换，将Foo的返回值进行局部移动（move语义）
>     ```

## 2、右值引用和左值引用

右值引用：用于拿到一个将亡值，延长该将亡值的生命周期 (变量 a 存在，将亡值就存在)

` T && a  = Foo();`

> string A = "123";//赋值
> 
> string& B = "123";//"123"是一个左值，可以左值引用
> 
> string&& C = "123";//
> 
> string&& D = std::move(A);//左值->右值，才能进行右值引用
> 
> //
> 
> const string&  E= A+A;//常量左值引用演唱临时变量生命周期，但E不能改变
> 
> string&& F = A+E；//右值引用延长临时变量的生命周期，但F可改 

- 非常量左引用无法引用右值：会造成逻辑错误。

- 常量左引用可以引用右值：Fortran需要

## 3、Move语义

> 传统C++：没有区分移动和拷贝概念。资源的移动都是先复制，再析构原来的对象，造成资源浪费，浪费时间
> 
> 现代C++：move，直接将原数据移动到新地方，不用拷贝也不用析构

```cpp
//vector例子

v.push_back(str);//调用push_back(const T&),产生拷贝行为
v.push_back(std::move(str));//push_back(const T&&),不产生拷贝
```

## 4、完美转发

> 传统C++：引用类型不能被继续引用
> 
> 现代c++：右值引用的出现，放宽原则，出现引用坍缩原则
> 
> | 函数形参类型 | 实参参数类型 | 推到后函数形参类型 |
> | ------ | ------ | --------- |
> | T&     | 左引用    | T&        |
> | T&     | 右引用    | T&        |
> | T&&    | 左引用    | T&        |
> | T&&    | 右引用    | T&&       |

完美转发：使用std::forward保证传递参数时保持原来的参数类型（左引用是左引用，右引用仍然是右引用）


