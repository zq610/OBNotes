# 函数
## 1.函数组成
- 返回类型
- 函数名
- 参数列表
- 函数体

> [!NOTE] 输入不合理值的处理方式
> 1. 终止程序` exit(-1);`
> 2. 抛出异常` throw "exception!";`
> 3. 修正函数原型 ` bool function(int a,int &elem);`
## 2.调用函数(invoke a function)
### 传参方式
- 传值(pass by value)：`void function(int a);`
- 传址(pass by reference)：`void function(int &a);`
	1. 语义：将参数a声明为引用reference=将a的内存地址当作参数传给函数；
	2. 原因：
		- 直接都传入的参数值进行修改；
		- 降低复制大型对象的额外负担；
		- reference to const vector `const vector<int>& vec`一目了然，目的是为了避免复制，而不是为了方便修改vector的值；
	3. 用途：多用于传递class object，传递内置类型int等直接传值就可以。

> [!NOTE] reference和pointer传参
> 相同：都能达到传递对象地址，避免复制的作用
> 不同：用法不同（指针需要解引用和判不空）

```C++
void display(const vector<int> &vec);
void diaplay(const vector<int> *vec);
//1.访问vector元素
vec[i];
(*vec)[i];
//2.pointer可以指向空，而reference必须指向实际值,所以指针需要先判非空再操作
```
### 作用域及范围
作用域
- local scope局部作用域：内置类型int等由程序员主动初始化。
	函数返回值一般都以值的方式返回：因为局部变量会在生存期末被销毁，只有以传值的方式返回一个副本才合法。pointer和reference都不合法。
- file scope：内置类型int等会自动被初始化为0
### 动态内存管理
通过new和delete在heap上分配和清理内存。
```C++
pi = new int(2014);
int *pia = new int[24];
delete pi;//清理pi指向的int对象
delete [] pia;//清理pia指向的数组内的所有对象。
！delete会自动检查指针是否为零，无需添加检查语句
```
### 默认参数值设置
- 默认参数值的设置放在函数参数列表的最右侧；
- 默认参数值一般放在函数声明处而非定义处
### 局部静态对象
**局部静态变量**的内存空间在不同的函数调用过程中共通，始终存在。
**局部变量**则在函数调用时建立，调用结束后销毁。
# inline函数
- 声明、定义一般放在
# 重载函数
# 函数模板
# 函数指针
