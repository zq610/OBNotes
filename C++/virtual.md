# 1、虚函数与运行多态

虚函数的调用取决于指向和引用的对象类型，而不是指针或者引用自身的类型

```cpp
class Base;
class Derived;
Base *base = new Derived;
base->func1();
//Base类型的指针指向Derived类，调用的也是Derived::func1();
```

# 2、vptr与vtable

每个类的vptr指向该类的vtable，vtable中有虚函数数量的条目，存放指向虚函数的指针

# 3、虚函数中的默认参数

- 虚函数动态绑定，取决于指针或引用指向的类型

- 默认参数静态绑定，取决于指针或引用本身的类型
  
  ```cpp
  Base *base = new Deirved();
  base->func1();
  //调用Derived::func()函数，但默认参数是Base的
  ```

# 4、注意的问题

## （1）静态函数不可以声明为虚函数，也不能被const和volatile修饰

- static成员函数不属于任何类对象或类实例，加上virtual无意义；

- 虚函数依靠vptr和vtable，但static成员函数没有this指针，无法访问在构造函数中创建生成的vptr

## （2）构造函数不可以声明为虚函数，有且只能使用inline/explicit关键字

- vptr在运行时通过构造函数创建，如果构造函数为虚函数，没有对应的vptr访问vtable；

- 构造函数用于初始化实例，类型明确，不需要虚函数这种在信息不全情况下进行多态运行的功能

## （3）析构函数可以为虚函数

- 拥有派生类的基类析构函数应该都声明为虚函数

- 因为在删除一个指向子类的基类指针时，应先调用子类析构函数，再调用基类析构函数，避免内存泄露。virtual可以实现这个机制

## （4）虚函数可以为私有函数

- 虚函数为私有：int main()必须为Base类友元，才能访问

- 基类public，子类private：不用讲int main()声明为友元

## （5）虚函数可以被内联

- 虚函数可以为内联函数，当且仅当编译器知道具体的类对象时（不是指针或者引用）

- 虚函数在表现多态时（运行期间），不可以被内联。因为编译器在编译时不知道具体调用哪个虚函数实现。
  
  ```cpp
  Base b;
  Derived d;
  b.func1();//func1()可内联
  d.func1();//func1()可内联
  Base *base;
  base->func1();//func1()不可内联
  ```

## （6）RTTI和dynamic_cast

### RTTI(Run_Time Type Identification)

通过运行时类型信息能够使用基类的指针或引用检查这些指针和引用实际指向对象的派生类型。

### dynamic_cast

比C风格强制类型转化和C++的 reinterpret_cast多提供**类型安全检查**，多用于在**多态类型之间转换**

## （7）纯虚函数和抽象类

- 纯虚函数：没有具体实现函数体的虚函数

- 抽象类：拥有纯虚函数的类。
  
  - 可以调用纯虚函数，析构函数和构造函数不能调用纯虚函数
  
  - 构造函数不能时纯虚函数，甚至不能是虚函数
  
  - 析构函数在多态时必须时虚析构函数
  
  - 不能创建类对象，只能作为派生子类的基类
  
  - 派生类必须实现所有的纯虚函数才能摆脱抽象类称号
