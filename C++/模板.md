# 模板

## 1、概述

### 概念

一种参数多态性的工具，为逻辑相同而类型不同的程序提供一种代码共享机制

- 非实在函数或类，只是一种描述，一种参数化的函数和类

- 分类
  
  - 函数模板
    
    提供通用的函数逻辑给不同类型的参数。
    
    在编译时，根据实际数据类型实例化对应函数。
    
     函数重载：需要重写函数（但可实现不同功能，更灵活），而函数模板不用重写函数代码，但只能针对不同的数据类型，逻辑不变。
  
  - 类模板
    
    用于设计成员完全相同，只是处理数据类型不同的通用类

## 2、函数模板

### 定义

`template<typename T1,typename T2>void GetPair(参数表T1 Name，T2 Num){}`

- 模板参数T1、T2，又称为类型参数或类属参数。

- 模板实例化时用实际的数据类型传递

- 参数表可包括类型参数和非类型参数两种，在调用时，非类型参数只能使用常量；

### 模板实例化

#### 1、时机

在编译时，遇到对函数模板的实际调用，根据实际的数据类型生成相应的模板实例化（模板函数）

在整个程序中，相同类型的模板函数只生成一次

#### 2、实例化方式

```cpp
//隐式实例化
GePair("cherry",5);
//显式实例化
GetPair<string,int>("Cherry",6);
```

#### 函数模板的特化

##### 1、定义

在针对模板不能处理的特殊数据类型时，编写与模板同名的特殊函数专门处理这些数据

`template<>void Compair<Base1,Base2>(参数表T1 Name，T2 Num){}``

- template<>中时模板特化后的关键字，不填内容

- 函数名Compair<>中是特化处理的数据类型

##### 2、特点

> 1、程序中同时存在模板和特化，优先调用特化；
> 
> 2、同一程序，函数模板、特化、普通函数可以同名。
> 
>         普通函数调用实参会进行隐式类型转换
> 
>          函数模板和特化的参数类型不会有类型转换
> 
> 3、调用顺序
> 
>         类型完全匹配的非模板函数
> 
>         类型完全匹配的模板函数
> 
>         类型相容的非模板函数

## 3、类模板

### 概念

用于设计成员和结构完全相同，只是处理数据类型不同的通用类

### 声明

```cpp
template<typename T1,typename T2，int num>
class Name{

};
```

### 参数

- 类型参数 ：即未知类型的参数。

- 非类型参数：具体的参数类型
  
  - 调用时只能提供相应类型的常量值
  
  - 非类型参数不能是void、类对象、浮点双精度型
  
  - 只能是int、enum、引用和指针(类对象、函数、类成员)

### 类模板成员函数定义

- 类外定义
  
  `template<模板参数**列表**>void Name<模板参数**名表**>::GetName(){}`

- 类内定义
  
  同普通函数一样

### 类模板特化

- 特化整个类模板
  
  `template<>`
  
  `class Compair<Base1,Base2>{}```

- 特化个别成员函数

```cpp
template<> void Array<char*>::Sort()
{

}
```
