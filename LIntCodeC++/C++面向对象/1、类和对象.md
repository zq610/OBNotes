### 1、封装
把对象的属性和行为封装为一个整体——类class
- 整体class
- 权限控制
	- public：都可以访问
	- private：类内访问
	- protected：类内访问
## 2、对象初始化/清理——构造/析构函数
编译器自动调用**构造和析构函数**，用于**对象初始化和清理**
- ==构造函数==：在创建对象时为对象的成员属性赋值
	```c++
	//1、构造函数语法
	类名 (){}
	//2、构造函数特点
	- 没有返回值；
	- 可以有参数，可以重载！！
	- （对象创建时）自动调用，且只调用一次
	```

- ==析构函数==：对象销毁前自动调用，执行清理工作
	```C++
	//1、析构函数语法
	~类名(){}
	//2、析构函数特点
	- 没有返回值
	-不可以有参数，不能重载！！
	- （对象销毁前）自动调用，且只调用一次
	
	```

## 3、构造函数的实例化和调用
### 1、构造函数的分类
- 按参数类型分类
	- 有参构造
	- 无参构造
- 按类型分类
	- 普通构造
	- 拷贝构造
```C++
//1、无参构造函数与调用
Person(){};
Person p;
//2、有参构造函数
Person(int a){ age = a; }
Person p(10);
//3、拷贝构造函数
Person(const Person& p){ age =p.age;}
```
### 2、构造函数的调用
#### 1、有参构造函数的调用方式
1. 括号法
2. 显示法
3. 隐式转换法
```C++
//1、括号法
Person p(10);
Person p1(p);//!不能利用拷贝构造初始化匿名对象，编译器会当作对象声明
//2、显示法
Person p = Person(10);(有参构造)
Person p1 = Person(p);（拷贝构造）
//3、隐式转换法
Person p1 = 10;（有参构造）
Person p2 = p1;（拷贝构造）
```
#### 2、拷贝构造函数的调用时机
1. 使用已创建的对象初始化另一个新对象
2. 值传递形式给函数参数传值
3. 以值方式返回局部对象
```C++
//1、使用已创建的对象初始化另一个新对象
Person p(10);
Person p1(p);//显示调用拷贝构造函数
Person p1 = p;//隐式转换调用拷贝构造函数
//2、值传递形式给函数参数传值
void function(Person p){}
int main()
{
	Person P;//调用无参构造函数
	function(p);//调用拷贝构造函数给function()传值
}
//3、以值方式返回局部
Person function()
{
	Person p1;
	retunrn  p1;
}

int main()
{
	Person p = function();
}

```

#### 3、调用规则
C++编译器默认添加3个函数
1. 默认无参构造函数
2. 默认无参析构函数
3. 默认拷贝构造函数：对属性进行值拷贝
调用规则：
1. 用户定义有参构造，C++不提供无参构造，但有拷贝构造函数
2. 用户定义拷贝构造函数，C++不提供任何构造函数
## 4、深拷贝与浅拷贝
- 浅拷贝：赋值拷贝
- 深拷贝：堆区重新申请空间，进行拷贝
```C++
//1、浅拷贝：默认拷贝构造函数(只复制指针，没有分配新的内存)
Person(const Person& p)
	:m_age(p.m_age),m_buffer(p.m_buffer)
{
}

Person p1;
Person p2(p1);//此时p2与p1的指针成员指向同一块内存，不仅相互影响，在delete时容易内存崩溃。

//2、深拷贝
Person(const Person& p)
	:m_age(p.m_age)
{
	m_buffer = new int[10];
	memcpy(m_buffer,p.m_buffer,10);
}
```
> [!NOTE] 注意！
> 1、Contents 成员属性含有堆区资源，需要自定义拷贝构造函数，避免浅拷贝带来的问题。
> 2、在不需要更改传入参数值时，用const & 传参可以避免不必要的类对象实例化和复制
